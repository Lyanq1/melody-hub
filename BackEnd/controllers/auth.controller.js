import {
  createAccount,
  findAccountByUsername,
  findAccountByEmail,
  findOrCreateFacebookAccount,
  updateAccount
} from '../models/auth/account.model.js'
import Account from '../models/auth/account.model.js'
import bcrypt from 'bcrypt'
import jwt from 'jsonwebtoken'
import axios from 'axios'
import config from '../config/config.js'
import { sendVerificationEmail, sendPasswordResetEmail } from '../utils/email.js'
import {
  createResetToken,
  findResetToken,
  markTokenAsUsed,
  deleteResetTokensByUsername
} from '../models/auth/resettoken.model.js'
import ResetToken from '../models/auth/resettoken.model.js'

// ƒêƒÉng k√Ω
export const register = async (req, res) => {
  console.log('Register endpoint hit with data:', JSON.stringify(req.body, null, 2))
  const { username, password, email, displayName, phone, address, role } = req.body

  const validRoles = ['Customer', 'Artist', 'Admin']
  if (!validRoles.includes(role)) {
    return res.status(400).json({ message: 'Invalid role' })
  }

  try {
    console.log('Checking for existing user with username:', username)
    const existingUser = await findAccountByUsername(username)
    console.log('Existing user check result:', existingUser)

    console.log('Checking for existing email:', email)
    const existingEmail = await findAccountByEmail(email)
    console.log('Existing email check result:', existingEmail)

    if (existingUser) {
      return res.status(400).json({ message: 'Username already exists' })
    }
    if (existingEmail) {
      return res.status(400).json({ message: 'Email already exists' })
    }

    // Create account with MongoDB
    console.log('Creating account with MongoDB...')
    const accountID = await createAccount(username, password, email, displayName, null, role, phone, address)
    console.log('Account created with ID:', accountID)

    await sendVerificationEmail(email, displayName) // G·ª≠i email x√°c nh·∫≠n

    console.log('Registration successful, returning response')
    res.status(201).json({ message: 'Registration successful', accountID })
  } catch (error) {
    console.error('Registration error:', error)
    res.status(500).json({ message: 'Error registering user', error: error.message })
  }
}

// ƒêƒÉng nh·∫≠p
export const login = async (req, res) => {
  console.log('login hit')
  const { username, password } = req.body

  try {
    const account = await findAccountByUsername(username)
    if (!account) {
      return res.status(400).json({ message: 'Invalid username or password' })
    }

    // For MongoDB, we use the comparePassword method
    const isMatch = await account.comparePassword(password)
    if (!isMatch) {
      return res.status(400).json({ message: 'Invalid username or password' })
    }

    console.log('üîë Creating JWT token with secret:', config.jwt.secret.substring(0, 10) + '...')
    const token = jwt.sign(
      { accountID: account._id, username: account.Username, role: account.Role },
      config.jwt.secret,
      { expiresIn: config.jwt.expiresIn }
    )
    console.log('‚úÖ JWT token created:', token.substring(0, 20) + '...')

    res.status(200).json({
      message: 'Login successful',
      token,
      user: {
        accountID: account._id,
        username: account.Username,
        email: account.Email,
        displayName: account.DisplayName,
        avatarURL: account.AvatarURL,
        role: account.Role
      }
    })
  } catch (error) {
    res.status(500).json({ message: 'Error logging in', error: error.message })
  }
}

// ƒêƒÉng nh·∫≠p qua Facebook
export const facebookLogin = async (req, res) => {
  const { accessToken, role } = req.body

  const validRoles = ['Customer', 'Artist', 'Admin']
  if (!validRoles.includes(role)) {
    return res.status(400).json({ message: 'Invalid role' })
  }

  try {
    // X√°c minh access token v·ªõi Facebook - l·∫•y th√™m th√¥ng tin chi ti·∫øt
    console.log('üîç Verifying Facebook access token and fetching user data...')
    const response = await axios.get(
      `https://graph.facebook.com/me?fields=id,email,name,picture.type(large).width(400).height(400)&access_token=${accessToken}`
    )
    const { id: facebookId, email, name, picture } = response.data

    console.log('üë§ Facebook user data received:', {
      facebookId,
      email,
      name,
      pictureUrl: picture?.data?.url
    })

    if (!email || !name) {
      return res.status(400).json({ message: 'Email and display name are required from Facebook' })
    }

    // T√¨m ho·∫∑c t·∫°o t√†i kho·∫£n Facebook
    const accountID = await findOrCreateFacebookAccount(facebookId, email, name, picture?.data?.url, role)

    // L·∫•y th√¥ng tin t√†i kho·∫£n ƒë·ªÉ ki·ªÉm tra v√† tr·∫£ v·ªÅ
    const account = await findAccountByEmail(email)

    // T·∫°o JWT token
    const token = jwt.sign({ accountID, username: `fb_${facebookId}`, role }, config.jwt.secret, {
      expiresIn: config.jwt.expiresIn
    })

    console.log('‚úÖ Facebook login successful for user:', account.DisplayName)
    res.status(200).json({
      message: 'Facebook login successful',
      token,
      user: {
        accountID: account._id,
        username: account.Username,
        email: account.Email,
        displayName: account.DisplayName,
        avatarURL: account.AvatarURL,
        role: account.Role,
        phone: account.Phone,
        address: account.Address
      }
    })
  } catch (error) {
    console.error('Facebook login error:', error.response?.data || error.message)
    res.status(500).json({ message: 'Error logging in with Facebook', error: error.message })
  }
}

export const getUserInfo = async (req, res) => {
  const { username } = req.params
  try {
    const account = await Account.findOne({ Username: username }).select('-Password')
    if (!account) {
      return res.status(404).json({ message: 'User not found' })
    }
    res.status(200).json(account)
  } catch (error) {
    res.status(500).json({ message: 'Server error', error: error.message })
  }
}

// Ki·ªÉm tra quy·ªÅn truy c·∫≠p dashboard
export const checkDashboardAccess = async (req, res) => {
  try {
    // Token ƒë√£ ƒë∆∞·ª£c verify b·ªüi middleware
    const { accountID, username, role } = req.user

    // Ki·ªÉm tra quy·ªÅn truy c·∫≠p dashboard
    const canAccess = role === 'Admin' || role === 'Artist'

    if (!canAccess) {
      return res.status(403).json({
        message: 'Access denied. Dashboard access requires Admin or Artist privileges.',
        canAccess: false
      })
    }

    // L·∫•y th√¥ng tin user t·ª´ database
    const account = await Account.findById(accountID).select('-Password')
    if (!account) {
      return res.status(404).json({ message: 'User not found' })
    }

    res.status(200).json({
      message: 'Access granted',
      canAccess: true,
      user: {
        accountID: account._id,
        username: account.Username,
        email: account.Email,
        displayName: account.DisplayName,
        avatarURL: account.AvatarURL,
        role: account.Role
      }
    })
  } catch (error) {
    console.error('Error checking dashboard access:', error)
    res.status(500).json({ message: 'Error checking access', error: error.message })
  }
}

// L·∫•y th√¥ng tin user hi·ªán t·∫°i t·ª´ token
export const getCurrentUser = async (req, res) => {
  try {
    // Token ƒë√£ ƒë∆∞·ª£c verify b·ªüi middleware
    const { accountID, username, role } = req.user

    // L·∫•y th√¥ng tin user t·ª´ database
    const account = await Account.findById(accountID).select('-Password')
    if (!account) {
      return res.status(404).json({ message: 'User not found' })
    }

    res.status(200).json({
      user: {
        accountID: account._id,
        username: account.Username,
        email: account.Email,
        displayName: account.DisplayName,
        avatarURL: account.AvatarURL,
        role: account.Role,
        phone: account.Phone,
        address: account.Address
      }
    })
  } catch (error) {
    console.error('Error getting current user:', error)
    res.status(500).json({ message: 'Error getting user info', error: error.message })
  }
}

// PUT /api/user/:username
export const updateUserInfo = async (req, res) => {
  const { username } = req.params
  const updatedData = req.body

  try {
    // console.log('üîÑ Updating user info for:', username)
    // console.log('üìù Raw update data:', updatedData)
    // console.log('üë§ Authenticated user:', req.user)

    // Filter out empty strings and undefined values to avoid overwriting existing data
    const cleanedData = {}
    Object.keys(updatedData).forEach((key) => {
      const value = updatedData[key]
      if (value !== undefined && value !== null && value !== '') {
        cleanedData[key] = value
      }
    })

    // console.log('üßπ Cleaned update data (non-empty only):', cleanedData)

    // Only proceed if there's actually data to update
    if (Object.keys(cleanedData).length === 0) {
      return res.status(400).json({ message: 'No valid data to update' })
    }

    // Add UpdatedAt timestamp
    cleanedData.UpdatedAt = new Date()

    // ƒê·ªëi v·ªõi session auth (Google users), ∆∞u ti√™n s·ª≠ d·ª•ng accountID t·ª´ authenticated user
    let account = null

    if (req.user && req.user.accountID) {
      // S·ª≠ d·ª•ng accountID t·ª´ middleware authentication
      account = await Account.findByIdAndUpdate(
        req.user.accountID,
        { $set: cleanedData }, // Use $set to only update specified fields
        { new: true, runValidators: true }
      ).select('-Password')
      console.log('‚úÖ Updated using accountID:', req.user.accountID)
    } else {
      // Fallback: t√¨m theo username (traditional auth)
      account = await Account.findOneAndUpdate(
        { Username: username },
        { $set: cleanedData }, // Use $set to only update specified fields
        { new: true, runValidators: true }
      ).select('-Password')
      console.log('‚úÖ Updated using username:', username)
    }

    if (!account) {
      console.log('‚ùå User not found')
      return res.status(404).json({ message: 'User not found' })
    }

    console.log('üéâ Update successful:', account.DisplayName)
    console.log('üìä Updated fields:', Object.keys(cleanedData))
    res.status(200).json({ message: 'User updated successfully', user: account })
  } catch (error) {
    console.error('üí• Update failed:', error)
    res.status(500).json({ message: 'Update failed', error: error.message })
  }
}

// H√†m t·∫°o m√£ x√°c th·ª±c ng·∫´u nhi√™n
const generateResetToken = () => {
  return Math.floor(100000 + Math.random() * 900000).toString() // 6 ch·ªØ s·ªë
}

// G·ª≠i m√£ x√°c th·ª±c kh√¥i ph·ª•c m·∫≠t kh·∫©u
export const requestPasswordReset = async (req, res) => {
  const { username } = req.body

  try {
    // T√¨m t√†i kho·∫£n theo username
    const account = await findAccountByUsername(username)
    if (!account) {
      return res.status(404).json({ message: 'T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i' })
    }

    // Ki·ªÉm tra xem t√†i kho·∫£n c√≥ email kh√¥ng
    if (!account.Email) {
      return res.status(400).json({ message: 'T√†i kho·∫£n n√†y kh√¥ng c√≥ email ƒë·ªÉ g·ª≠i m√£ x√°c th·ª±c' })
    }

    // Ki·ªÉm tra format email (optional - n·∫øu mu·ªën validation ch·∫∑t ch·∫Ω h∆°n)
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(account.Email)) {
      return res.status(400).json({ message: 'Email kh√¥ng h·ª£p l·ªá' })
    }

    // T·∫°o m√£ x√°c th·ª±c
    const resetToken = generateResetToken()

    // L∆∞u token v√†o database
    await createResetToken(account.Username, account.Email, resetToken, 15) // 15 ph√∫t

    // G·ª≠i email ch·ª©a m√£ x√°c th·ª±c
    await sendPasswordResetEmail(account.Email, account.DisplayName, resetToken)

    res.status(200).json({
      message: 'M√£ x√°c th·ª±c ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email c·ªßa b·∫°n',
      email: account.Email // Tr·∫£ v·ªÅ email ƒë·ªÉ frontend c√≥ th·ªÉ hi·ªÉn th·ªã
    })
  } catch (error) {
    console.error('Error requesting password reset:', error)
    res.status(500).json({ message: 'L·ªói khi g·ª≠i m√£ x√°c th·ª±c', error: error.message })
  }
}

// X√°c th·ª±c m√£ reset password
export const verifyResetCode = async (req, res) => {
  const { username, token } = req.body

  try {
    console.log('Verifying reset code for username:', username, 'token:', token)

    // T√¨m t√†i kho·∫£n
    const account = await findAccountByUsername(username)
    if (!account) {
      console.log('Account not found for username:', username)
      return res.status(404).json({ message: 'T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i' })
    }

    console.log('Account found:', account.Username)

    // T√¨m v√† x√°c th·ª±c token
    const resetToken = await findResetToken(token)
    if (!resetToken) {
      console.log('Reset token not found or expired for token:', token)
      return res.status(400).json({ message: 'M√£ x√°c th·ª±c kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n' })
    }

    console.log('Reset token found:', {
      username: resetToken.username,
      token: resetToken.token,
      isUsed: resetToken.isUsed,
      expiresAt: resetToken.expiresAt
    })

    // Ki·ªÉm tra xem token c√≥ ƒë√∫ng cho username n√†y kh√¥ng
    if (resetToken.username !== username) {
      console.log('Token username mismatch:', resetToken.username, 'vs', username)
      return res.status(400).json({ message: 'M√£ x√°c th·ª±c kh√¥ng ƒë√∫ng cho t√†i kho·∫£n n√†y' })
    }

    console.log('Token verification successful')
    res.status(200).json({ message: 'M√£ x√°c th·ª±c h·ª£p l·ªá' })
  } catch (error) {
    console.error('Error verifying reset code:', error)
    res.status(500).json({ message: 'L·ªói khi x√°c th·ª±c m√£', error: error.message })
  }
}

// X√°c th·ª±c m√£ v√† ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u
export const resetPassword = async (req, res) => {
  const { username, token, newPassword } = req.body

  try {
    // T√¨m t√†i kho·∫£n
    const account = await findAccountByUsername(username)
    if (!account) {
      return res.status(404).json({ message: 'T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i' })
    }

    // T√¨m v√† x√°c th·ª±c token
    const resetToken = await findResetToken(token)
    if (!resetToken) {
      return res.status(400).json({ message: 'M√£ x√°c th·ª±c kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n' })
    }

    // Ki·ªÉm tra xem token c√≥ ƒë√∫ng cho username n√†y kh√¥ng
    if (resetToken.username !== username) {
      return res.status(400).json({ message: 'M√£ x√°c th·ª±c kh√¥ng ƒë√∫ng cho t√†i kho·∫£n n√†y' })
    }

    // Ki·ªÉm tra xem token ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng ch∆∞a
    if (resetToken.isUsed) {
      return res.status(400).json({ message: 'M√£ x√°c th·ª±c ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng' })
    }

    // C·∫≠p nh·∫≠t m·∫≠t kh·∫©u m·ªõi (s·∫Ω ƒë∆∞·ª£c hash trong pre-save middleware)
    await updateAccount(account._id, { Password: newPassword })

    // ƒê√°nh d·∫•u token ƒë√£ s·ª≠ d·ª•ng
    await markTokenAsUsed(token)

    res.status(200).json({ message: 'M·∫≠t kh·∫©u ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t l·∫°i th√†nh c√¥ng' })
  } catch (error) {
    console.error('Error resetting password:', error)
    res.status(500).json({ message: 'L·ªói khi ƒë·∫∑t l·∫°i m·∫≠t kh·∫©u', error: error.message })
  }
}

// Change password for authenticated user
export const changePassword = async (req, res) => {
  const { username } = req.params
  const { currentPassword, newPassword } = req.body

  try {
    console.log('üîí Change password request for username:', username)

    // Validate input
    if (!currentPassword || !newPassword) {
      return res.status(400).json({ message: 'Vui l√≤ng cung c·∫•p m·∫≠t kh·∫©u hi·ªán t·∫°i v√† m·∫≠t kh·∫©u m·ªõi' })
    }

    if (newPassword.length < 6) {
      return res.status(400).json({ message: 'M·∫≠t kh·∫©u m·ªõi ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±' })
    }

    if (currentPassword === newPassword) {
      return res.status(400).json({ message: 'M·∫≠t kh·∫©u m·ªõi ph·∫£i kh√°c m·∫≠t kh·∫©u hi·ªán t·∫°i' })
    }

    // Find account
    const account = await findAccountByUsername(username)
    if (!account) {
      return res.status(404).json({ message: 'T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i' })
    }

    // Verify current password
    const isCurrentPasswordValid = await account.comparePassword(currentPassword)
    if (!isCurrentPasswordValid) {
      console.log('‚ùå Current password is incorrect for user:', username)
      return res.status(400).json({ message: 'M·∫≠t kh·∫©u hi·ªán t·∫°i kh√¥ng ƒë√∫ng' })
    }

    console.log('‚úÖ Current password verified for user:', username)

    // Update password (will be hashed in pre-save middleware)
    await updateAccount(account._id, { Password: newPassword })

    console.log('‚úÖ Password updated successfully for user:', username)
    res.status(200).json({ message: 'ƒê·ªïi m·∫≠t kh·∫©u th√†nh c√¥ng' })

  } catch (error) {
    console.error('‚ùå Error changing password:', error)
    res.status(500).json({ message: 'L·ªói khi ƒë·ªïi m·∫≠t kh·∫©u', error: error.message })
  }
}

// Upsert Google user sent from NextAuth callback
export const googleSync = async (req, res) => {
  try {
    console.log('[googleSync] incoming body:', JSON.stringify(req.body))
    const { sub, email, name, picture, role } = req.body || {}
    const finalRole = ['Customer', 'Artist', 'Admin'].includes(role) ? role : 'Customer'

    if (!email || !sub) {
      return res.status(400).json({ message: 'Missing required fields: email, sub' })
    }

    const username = `google_${sub}`

    // Try find by email first
    let account = await findAccountByEmail(email)

    if (!account) {
      // If not found, create new account
      const randomPassword = `GOOGLE_${sub}`
      const accountID = await createAccount(
        username,
        randomPassword,
        email,
        name || 'Google User',
        picture || null,
        finalRole,
        null,
        null
      )
      account = await Account.findById(accountID)
      console.log('[googleSync] created account', accountID)
    } else {
      // Update profile fields if changed; do not overwrite Username
      const update = {}
      if (name && name !== account.DisplayName) update.DisplayName = name
      if (picture && picture !== account.AvatarURL) update.AvatarURL = picture
      if (Object.keys(update).length) {
        await updateAccount(account._id, update)
      }
      account = await Account.findById(account._id)
      console.log('[googleSync] updated account', account._id.toString())
    }

    // üîë Generate JWT token for Google user (same as traditional login)
    const token = jwt.sign(
      {
        accountID: account._id,
        username: account.Username,
        role: account.Role
      },
      config.jwt.secret,
      { expiresIn: config.jwt.expiresIn }
    )
    console.log('‚úÖ JWT token created for Google user:', token.substring(0, 20) + '...')

    return res.status(200).json({
      success: true,
      token, // üîë Include token in response
      user: {
        accountID: account._id,
        username: account.Username,
        email: account.Email,
        displayName: account.DisplayName,
        avatarURL: account.AvatarURL,
        role: account.Role,
        phone: account.Phone,
        address: account.Address
      }
    })
  } catch (error) {
    console.error('googleSync error:', error)
    return res.status(500).json({ message: 'Failed to sync Google user', error: error.message })
  }
}
